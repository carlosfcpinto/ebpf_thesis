(Introduction and what the problem is there to solve)
Introduction 
- Motivation
- Document Organization


(What I know the problem is)
Core Concepts e State of the Art
- Introduction
- Core Concepts of Blockchains
    + Introduction
    + SMR
    + Blockchains
        + What is a Blockchain
    + Network Types
        + What are this types
        + Synchronous           Networks
        + Asynchronous          Networks
        + Partially Synchronous Networks
    + Consensus
        + What is a Consensus
        + Why they are relevant to Blockchain
        + What do they do in Blockchain Networks
        + Blockchain network types (permissioned and permissionless)
        + Processes of Block creationg
        + What is the trillema and is a point (there are more) of comparisson and thats why we are testing, and this is the most relevant.


- State of the Art of Consensus Algorithms for Blockchains
    + Introduction
    + Proof of Work 
        + Explain the following:
            + How it works (cryptographic hard problems)
            + Explain the concept of sybil attacks in a permissionless environment
            + Explain what is mining and how it's done
                + How it's used for: 
                    + Leader selection
                    + Enforce block timing (with difficulty adjustment)
                    + Prevention of sybil attacks, as anyone can generate "accounts" or public keys

        + Nakamoto Consensus as the first proof of work consensus


        + Probabilistic Finality (They eventually decide on a branch, with a chance) Faul tolerant (Permissionless context) and all Nodes (functioning ones) eventually decide on a block (FLP Theorem)
            + Finality - Explain how is Probabilistic Finality (waiting for confirmations)
            + Fault Tolerant - Explain how it's BFT (PoW achieves BFT through making mining an expensive and complex process. A malicious actor or node that tries to alter a block’s data will need to re-mine that block and any block that comes after it in the blockchain. Because of the expensive mining process, the malicious actor will not be able to catch up with the rest of the network in order to form the longest blockchain. There is a strong incentive for each mining node to follow the longest blockchain to increase the probability of the mined block being accepted by other nodes in the network.)
            + Termination - Every (functioning) node decides on a value, even if the value decided is not the final one.

        + Fault tolerant (any node can join and exit at any time) that chooses availability over consistency (CAP Theorem)
            + Consistency - Is not consistent, and is Probabilistic like finality, since a node might not have a block yet
            + Availability - PoW is available because, at any point in time, miners are trying to mine new blocks to add to the blockchain. There is no state in which miners are blocked from mining in order to add new blocks to the blockchain. The difficulty level of mining a block is adjusted periodically to ensure that a new block can be mined roughly in x time.
            + Partition Tolerant - Even if an amount of nodes stop working, the blockchain still works

        + Ways of improving this Consensus
            + (Refer the trillema)
            + Improving Scalabiltity
                + Decoupling of blockchain functions
                + Parallel Chains
                + DAG-based protocols
            + Improving Security
                + Changing the incentive in the chain and how's shared
            + Improving Decentralization
                + de-incentivise centralization like pool mining
                + incentivise decentralized/solo mining, using process like erradicating ASIC mining

    - Proof of Stake
        - Explain how it works: based on the idea of stake, comitees, etc
        - Compare to Proof of Work
        - Explain the concept of "The bigger the stake, the bigger the chance of being selected"
        - Two main types: ChainPoS and BFT (recall what was said on consensus Algorithms here)
        - Chain Proof of Stake:
            - How it's formally defined:
                - A comitee is designed for each epoch, where the comitee is responsible to create new blocks
                - A block is generated by a single member of the comitee, which is the leader
                - The leader changes during the poch
            - How it's similar to the Nakamoto consensus, but selection is done through the amount of stake


    - Proof of Storage and Others
        - Make a small reference but recall that we are focuses on Application Layer Like blockchain networks

    - The Tezos blockchain

(Qual é o problema, e como é que vamos resolver o problema)
- Problem and Solution
    + The Problem
    + Talk about Soft Forks and Hard Forks.
        
    + The Solution
        + Method of testing and easily swaping consensus algorithms: Which includes
            + Taking a already built blockchain and make it suitable for both swapping and testing
            + One of the ideas was using tezos (explained later why) where we are taking out the consensus and add a layer of adaptability to it

    + The Experiment for the solution:
        + Introduction
            + expose that tezos was selected for this Experimentation
            + and to learn how to implement consensus algoriths I implement a proof of work on tezos
        + Why Tezos was the choice: 
            + Explain how it's upgradable
            + Explain how it's a good fit (it's a comercially/industrially used chain)
                + Because it's upgradable, the consensus in the codebase is independent and it's made for the replacement of such
                + As a brief description, Tezos was developed with the idea of being easily upgradable/where the consensus algorithm could be changed
                + But "unitentionally" (get another word for this), upgrading the consensus can be boiled down to actually changing the protocol/consensus
            + Develop something to deploy multiple nodes and actually test this in a running live network
            + Doing so, it could be easily implemented an API/Adaptative layer that enables the connection with what is compiled from DSL, or a  Way to do the actual swapping, and test metrics
            + The idea of the protocol is stateless, independent from other stuff like p2p, on-disk storage, verifications, dataencoding, client (refer to what was said previously in the solution section), etc, making it only having to focus on writing the actual protocol, and not worry about other stuff

        + How is Tezos structured to allow such upgrades
            + Explain the software architecure
            + Explain the upgrading concept
            + The communication between the shell and the protocol
            + Explain how the protocol works 

        + Implementation of the experiment
        

            + The implementation of the experiment
                + Explain why I implemented Proof of Work 
                    + As a way to learn how protocols are implemented and structured
                    + Learning how they are implemented is important to know what work has to be done to later test and add the adaptative layer to the DSL like mentioned
                    + Also important to learn how tezos handles the protocols, and how the protocols are executed in the tezos chain
                    + It's somewhat different from Tezos original proof of stake, using it as an argument that it can be used to implement other consensus

            + Explain how I implemented Proof of Work
                + How it's compiled against an environment and uses a TEZOS_PROTOCOl file thing
                + Implementation of the lib_protocol
                    + Implementing the Protocol Header
                    + Implementing the Representations (*-repr.ml) and Storage (*-storage.ml) and Storage overall
                        + Representations: - Accounts/Manager, Constants/Parameters Header, Time, Target, Tez, Operations (Reveal and Transaction)
                        + How the information is actually stored (it's abstracted)
                        + Accounts, Target and Epoch Time
                    + Implementing Alpha_context and Raw_context 
                        + Alpha_context is the Consensus view of things
                        + Raw_context is the Raw/Storage/non abstract view of what is done in the consensus
                    + Implementation of the API part of the shell (begin construction, etc) 
                    + Implementing RPC services
                + Explain what it doesn't have, but weren't the main point of the excercise
                    + Smart Contracts, but could be added on top
                    + Upgradability, but could be added

                + Implementation of the client
                    + This can be done independently from the tezos project, since it only communicates using JSON RPC
                    + Injection of Commands and the request of the protocol information through the use of RPC services

                + Implementation of the baker
                    + This can be done independently from the tezos project, since it only communicates using JSON RPC
                    + Uses the client and shell services to form a block
                    + How it actually mines

            
- Tasks
    - Finish Proof Of Work protocol in tezos
    - test proof of work
    - Make it more easy and generic to add newer consensus algorithms
    - Make a platform to test those algorithms
    - Make other tools

